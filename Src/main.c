/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f4xx.h"

int main(void)
{
	SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOBEN); 				// enable GPIOB
	SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN); 					// enable TIM4

	// pin enable PB6-PB9 to alternate function
	CLEAR_BIT(GPIOB->MODER, GPIO_MODER_MODER6_0);
	SET_BIT(GPIOB-> MODER, GPIO_MODER_MODER6_1);
	CLEAR_BIT(GPIOB->MODER, GPIO_MODER_MODER7_0);
	SET_BIT(GPIOB-> MODER, GPIO_MODER_MODER7_1);
	CLEAR_BIT(GPIOB->MODER, GPIO_MODER_MODER8_0);
	SET_BIT(GPIOB-> MODER, GPIO_MODER_MODER8_1);
	CLEAR_BIT(GPIOB->MODER, GPIO_MODER_MODER9_0);
	SET_BIT(GPIOB-> MODER, GPIO_MODER_MODER9_1);

	// enable PB6 to AF2 - ch1 for tim4
	SET_BIT(GPIOB->AFR[0], 2<<24);
	SET_BIT(GPIOB->AFR[0], 2<<28);
	SET_BIT(GPIOB->AFR[1], 2<<0);
	SET_BIT(GPIOB->AFR[1], 2<<4);

	// CR1 register
	CLEAR_BIT(TIM4->CR1, TIM_CR1_DIR);							// upcounting
	CLEAR_BIT(TIM4->CR1, TIM_CR1_CMS); 							// 00: Edge-aligned mode. The counter counts up or down depending on the direction bit
	(DIR).

	// CCMR1 and CCMR2 register - mode register for channel 1, 2, 3, 4
	// channel 1
	CLEAR_BIT(TIM4-> CCMR1, TIM_CCMR1_CC1S); 					// nastavimmo channel 1 na output
	SET_BIT(TIM4-> CCMR1, TIM_CCMR1_OC1PE); 					// TIMx_CCR1 enabled. Read/Write operations access the preload register
	CLEAR_BIT(TIM4-> CCMR1, TIM_CCMR1_OC1M_0);  				// PWM mode 1 (110) -> channel 1 is active as long as TIMx_CNT<TIMx_CCR1
	SET_BIT(TIM4-> CCMR1, TIM_CCMR1_OC1M_1);
	SET_BIT(TIM4-> CCMR1, TIM_CCMR1_OC1M_2);

	// channel 2
	CLEAR_BIT(TIM4-> CCMR1, TIM_CCMR1_CC2S);
	SET_BIT(TIM4-> CCMR1, TIM_CCMR1_OC2PE);
	CLEAR_BIT(TIM4-> CCMR1, TIM_CCMR1_OC2M_0);
	SET_BIT(TIM4-> CCMR1, TIM_CCMR1_OC2M_1);
	SET_BIT(TIM4-> CCMR1, TIM_CCMR1_OC2M_2);

	// channel 3
	CLEAR_BIT(TIM4-> CCMR2, TIM_CCMR2_CC3S);
	SET_BIT(TIM4-> CCMR2, TIM_CCMR2_OC3PE);
	CLEAR_BIT(TIM4-> CCMR2, TIM_CCMR2_OC3M_0);
	SET_BIT(TIM4-> CCMR2, TIM_CCMR2_OC3M_1);
	SET_BIT(TIM4-> CCMR2, TIM_CCMR2_OC3M_2);

	// channel 4
	CLEAR_BIT(TIM4-> CCMR2, TIM_CCMR2_CC4S);
	SET_BIT(TIM4-> CCMR2, TIM_CCMR2_OC4PE);
	CLEAR_BIT(TIM4-> CCMR2, TIM_CCMR2_OC4M_0);
	SET_BIT(TIM4-> CCMR2, TIM_CCMR2_OC4M_1);
	SET_BIT(TIM4-> CCMR2, TIM_CCMR2_OC4M_2);

	// Register CCER
	// configure ccxp and ccxe
	SET_BIT(TIM4 -> CCER, TIM_CCER_CC1E); 					// it enables capture so that channel can send mixed signal
	SET_BIT(TIM4 -> CCER, TIM_CCER_CC1P); 					// active low, channel will be on 0
	SET_BIT(TIM4 -> CCER, TIM_CCER_CC2E);
	SET_BIT(TIM4 -> CCER, TIM_CCER_CC2P);
	SET_BIT(TIM4 -> CCER, TIM_CCER_CC3E);
	SET_BIT(TIM4 -> CCER, TIM_CCER_CC3P);
	SET_BIT(TIM4 -> CCER, TIM_CCER_CC4E);
	SET_BIT(TIM4 -> CCER, TIM_CCER_CC4P);

	// timer configure
	TIM4 -> PSC = 15999;
	TIM4 -> ARR = 4999;  									// 16MHZ / 16K * 5000 = 5s - period
	TIM4 -> CCR1 = 1000;
	TIM4 -> CCR2 = 2000;
	TIM4 -> CCR3 = 3000;
	TIM4 -> CCR4 = 4000;
	TIM4 -> CNT = 0;

	SET_BIT(TIM4->EGR, TIM_EGR_UG);     					// update registers

	CLEAR_BIT(TIM4->SR, TIM_SR_UIF);   						// clear flag
	SET_BIT(TIM4->CR1, TIM_CR1_CEN);    					// enable TIM4

	while (1)
	{

	}

}
